---
phase: 16-encode-decode-code-visualization
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - src/distill/ui/tabs/codes_tab.py
  - src/distill/ui/tabs/__init__.py
  - src/distill/ui/app.py
autonomous: true
requirements: [CODE-01, CODE-02, CODE-03, CODE-07, CODE-09]

must_haves:
  truths:
    - "User can select a trained VQ-VAE model from a dropdown (v1.0 models filtered out)"
    - "User can upload an audio file and click Encode to see the code grid"
    - "User can click any cell in the grid to hear that codebook entry as audio"
    - "User can click a column header to hear the full time-slice decoded"
    - "User can click Play on a row label to hear that level's contribution across time"
    - "User can click Decode to hear the full reconstruction and compare side-by-side with original"
    - "Grid shows level labels (Structure/Timbre/Detail) as sticky row headers"
    - "Playhead sweeps across grid during audio playback"
  artifacts:
    - path: "src/distill/ui/tabs/codes_tab.py"
      provides: "Complete Codes tab with model selector, encode/decode, grid, audio players"
      exports: ["build_codes_tab"]
      min_lines: 200
    - path: "src/distill/ui/app.py"
      provides: "Codes tab registered alongside Data/Train/Generate/Library"
      contains: "codes_tab"
  key_links:
    - from: "src/distill/ui/tabs/codes_tab.py"
      to: "distill.inference.codes"
      via: "encode_audio_file, decode_code_grid, preview_single_code, preview_time_slice, play_row_audio"
      pattern: "from distill\\.inference\\.codes import"
    - from: "src/distill/ui/tabs/codes_tab.py"
      to: "distill.ui.components.code_grid"
      via: "render_code_grid, get_level_labels"
      pattern: "from distill\\.ui\\.components\\.code_grid import"
    - from: "src/distill/ui/tabs/codes_tab.py"
      to: "hidden Textbox #code-grid-cell-clicked"
      via: "cell_clicked.change -> _handle_cell_click -> preview_audio"
      pattern: "code-grid-cell-clicked"
    - from: "src/distill/ui/app.py"
      to: "src/distill/ui/tabs/codes_tab.py"
      via: "import build_codes_tab, gr.Tab('Codes')"
      pattern: "build_codes_tab"
---

<objective>
Build the Codes tab UI that wires the encode/decode pipeline and grid renderer from Plan 01 into a complete interactive experience, and register it in the main application.

Purpose: Give users a dedicated tab to encode audio into discrete codes, visualize them as an interactive grid, preview individual codebook entries by clicking, and decode back to audio for A/B comparison. This is the primary interface for understanding how the VQ-VAE represents audio before editing in Phase 17.

Output:
- `src/distill/ui/tabs/codes_tab.py` -- Complete Codes tab builder
- `src/distill/ui/app.py` -- Tab registration and cross-tab wiring
</objective>

<execution_context>
@C:/Users/Taylor/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Taylor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-encode-decode-code-visualization/16-RESEARCH.md
@.planning/phases/16-encode-decode-code-visualization/16-01-SUMMARY.md

@src/distill/ui/app.py
@src/distill/ui/state.py
@src/distill/ui/tabs/generate_tab.py
@src/distill/ui/tabs/library_tab.py
@src/distill/ui/components/model_card.py
@src/distill/inference/codes.py
@src/distill/ui/components/code_grid.py

<interfaces>
<!-- Key types and contracts from Plan 01 output -->

From src/distill/inference/codes.py (created in Plan 01):
```python
def encode_audio_file(audio_path: Path, loaded: LoadedVQModel) -> dict:
    """Returns dict with: indices, spatial_shape, mel_shape, num_quantizers, codebook_size, duration_s"""

def decode_code_grid(indices: torch.Tensor, spatial_shape: tuple, mel_shape: tuple, loaded: LoadedVQModel) -> np.ndarray:
    """Returns 1-D float32 numpy array at 48kHz"""

def preview_single_code(level: int, code_index: int, loaded: LoadedVQModel, spatial_shape: tuple, mel_shape: tuple) -> np.ndarray:
    """Returns 1-D float32 numpy array"""

def preview_time_slice(position: int, full_indices: torch.Tensor, loaded: LoadedVQModel, spatial_shape: tuple, mel_shape: tuple) -> np.ndarray:
    """Returns 1-D float32 numpy array"""

def play_row_audio(level: int, full_indices: torch.Tensor, loaded: LoadedVQModel, spatial_shape: tuple, mel_shape: tuple) -> np.ndarray:
    """Returns 1-D float32 numpy concatenation"""
```

From src/distill/ui/components/code_grid.py (created in Plan 01):
```python
DEFAULT_LEVEL_LABELS = {2: [...], 3: [...], 4: [...]}

def get_level_labels(num_quantizers: int, custom_labels: list[str] | None = None) -> list[str]: ...

def render_code_grid(
    indices: torch.Tensor | None,
    num_quantizers: int,
    codebook_size: int,
    spatial_shape: tuple[int, int],
    level_labels: list[str],
    selected_cell: tuple[int, int] | None,
    duration_s: float,
) -> str:
    """Returns HTML string with CSS grid, JS onclick bridge, playhead."""
```

From src/distill/ui/state.py:
```python
@dataclass
class AppState:
    loaded_vq_model: Optional[LoadedVQModel] = None
    model_library: Optional[ModelLibrary] = None
    models_dir: Path = ...
    device: Optional[torch.device] = None

app_state = AppState()
```

From src/distill/ui/app.py (current tab registration):
```python
with gr.Tabs():
    with gr.Tab("Data", id="data"): ...
    with gr.Tab("Train", id="train"): ...
    with gr.Tab("Generate", id="generate"): ...
    with gr.Tab("Library", id="library"): ...
```

From src/distill/models/persistence.py:
```python
def load_model_v2(model_path: Path, device: torch.device) -> LoadedVQModel: ...
```

From src/distill/cli/generate.py (model version detection pattern):
```python
def _detect_model_version(model_path: Path) -> tuple[int, str]:
    """Peek at .distill file. Returns (version, model_type) e.g. (2, 'vqvae')."""
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create codes_tab.py with full Codes tab layout and event handlers</name>
  <files>
    src/distill/ui/tabs/codes_tab.py
    src/distill/ui/tabs/__init__.py
  </files>
  <action>
Create `src/distill/ui/tabs/codes_tab.py` following the established tab builder pattern (see `generate_tab.py`).

**`build_codes_tab()` function** returns a dict of component references for cross-tab wiring.

**Layout structure (top to bottom):**

1. **Controls row** (top):
   - `gr.Dropdown` for model selection -- label "VQ-VAE Model", filterable. Populate with VQ-VAE models only (v2 format). Use a helper `_get_vqvae_model_choices()` that scans `app_state.models_dir` for `.distill` files, peeks at each with `torch.load(..., weights_only=True)` to check `version >= 2 and model_type == "vqvae"`, and returns names. Follow the `_detect_model_version` pattern from `cli/generate.py`.
   - `gr.Audio` for audio upload -- label "Audio File", source types file upload, type="filepath"
   - `gr.Button("Encode")` -- primary action
   - `gr.Button("Decode")` -- secondary, decodes current grid back to audio

2. **Level label editor** (collapsible `gr.Accordion`, open=False):
   - One `gr.Textbox` per level (populated with defaults after encode)
   - "Apply Labels" button to re-render grid with custom labels

3. **Code grid display** (main area):
   - `gr.HTML` with `elem_id="code-grid-container"` -- populated by `render_code_grid()`
   - Hidden `gr.Textbox(visible=False, elem_id="code-grid-cell-clicked")` for JS->Python bridge

4. **Audio players row** (below grid):
   - `gr.Audio(label="Original Audio", interactive=False)` -- plays the uploaded file
   - `gr.Audio(label="Decoded Reconstruction", interactive=False)` -- plays decoded output
   - `gr.Audio(label="Preview", interactive=False, autoplay=True)` -- plays cell/column/row previews

**Event handlers (module-level functions, not lambdas):**

1. **`_load_model(model_name)`** -- Load selected VQ-VAE model.
   - Find the model file path from `app_state.models_dir` (scan .distill files for matching name in metadata, or use `app_state.model_library` if it provides a lookup)
   - Call `load_model_v2(path, app_state.device)`
   - Store result in `app_state.loaded_vq_model`
   - Return status message

2. **`_encode_audio(audio_path, model_name)`** -- Encode uploaded audio.
   - Guard: check `app_state.loaded_vq_model is not None`, else return error
   - Guard: check audio_path is not None/empty
   - Call `encode_audio_file(Path(audio_path), app_state.loaded_vq_model)`
   - Store result dict in module-level state variable `_current_encode` (dict with indices, spatial_shape, mel_shape, etc.)
   - Get level labels via `get_level_labels(result['num_quantizers'])`
   - Render grid via `render_code_grid(result['indices'], ...)`
   - Return: grid HTML, original audio path (for original player), level label textbox updates, status
   - Also return the `(48000, wav_array)` tuple for decoded audio player (auto-decode on encode for immediate A/B)

3. **`_decode_current()`** -- Decode current code grid to audio.
   - Guard: check `_current_encode is not None`
   - Call `decode_code_grid(_current_encode['indices'], ...)`
   - Return `(48000, wav_array)` tuple for the decoded audio player

4. **`_handle_cell_click(click_info)`** -- Parse click info from hidden textbox.
   - Parse the string: `"cell,{level},{position}"` or `"col,{position}"` or `"row,{level}"`
   - For `"cell"`: call `preview_single_code(level, code_index, ...)` where code_index is read from `_current_encode['indices'][0, position, level]`. Also re-render grid with `selected_cell=(level, position)` and return updated HTML.
   - For `"col"`: call `preview_time_slice(position, ...)`
   - For `"row"`: call `play_row_audio(level, ...)`
   - Return: `(48000, audio_array)` for preview player, updated grid HTML (for selection highlight)

5. **`_update_level_labels(*label_texts)`** -- Re-render grid with custom labels.
   - Collect label texts into a list
   - Re-render with custom labels
   - Return updated grid HTML

**Module-level state:**
- `_current_encode: dict | None = None` -- stores latest encode result (indices, spatial_shape, mel_shape, etc.)
- `_current_labels: list[str] | None = None` -- stores current level labels

**Event wiring inside build_codes_tab():**
- `model_dropdown.change` -> `_load_model` -> status display
- `encode_btn.click` -> `_encode_audio` inputs=[audio_input, model_dropdown] outputs=[grid_html, original_audio, decoded_audio, label_textboxes..., status]
- `decode_btn.click` -> `_decode_current` -> decoded_audio player
- `cell_clicked.change` -> `_handle_cell_click` inputs=[cell_clicked] outputs=[preview_audio, grid_html]
- `apply_labels_btn.click` -> `_update_level_labels` inputs=[label_textboxes] outputs=[grid_html]

**Return dict keys for cross-tab wiring:**
```python
return {
    "model_dropdown": model_dropdown,
    "grid_html": grid_html,
    "status": status_msg,
}
```

Also update `src/distill/ui/tabs/__init__.py` if it has exports -- add `codes_tab` reference (or leave empty if __init__.py has no explicit exports; check the file first).
  </action>
  <verify>
    <automated>cd H:/dev/Distill-vqvae && python -c "from distill.ui.tabs.codes_tab import build_codes_tab; print('Codes tab importable')"</automated>
  </verify>
  <done>
    - build_codes_tab() creates a complete Codes tab with model selector, audio upload, encode/decode buttons, code grid, and audio players
    - Model dropdown only shows VQ-VAE (v2) models
    - Encode handler calls encode_audio_file and renders grid
    - Cell/column/row click handlers dispatch to appropriate preview functions
    - Level labels editable via accordion
    - Side-by-side original vs decoded audio players
    - Preview audio player with autoplay
  </done>
</task>

<task type="auto">
  <name>Task 2: Register Codes tab in app.py and wire cross-tab events</name>
  <files>src/distill/ui/app.py</files>
  <action>
Modify `src/distill/ui/app.py` to:

1. **Import the Codes tab builder:**
   Add `from distill.ui.tabs.codes_tab import build_codes_tab` alongside the existing tab imports at the top of the file.

2. **Add the Codes tab in the tab layout:**
   Insert a new `gr.Tab("Codes", id="codes")` between the Generate tab and Library tab (or after Library -- position after Generate makes sense since it is the next logical step after generation). Inside the tab block, call `codes_refs = build_codes_tab()`.

   The tab layout should become:
   ```python
   with gr.Tabs():
       with gr.Tab("Data", id="data"):
           data_refs = build_data_tab()
       with gr.Tab("Train", id="train"):
           train_refs = build_train_tab()
       with gr.Tab("Generate", id="generate"):
           gen_refs = build_generate_tab()
       with gr.Tab("Codes", id="codes"):
           codes_refs = build_codes_tab()
       with gr.Tab("Library", id="library"):
           lib_refs = build_library_tab()
   ```

3. **Wire cross-tab events:**
   After a model is loaded from the Library tab (existing `lib_refs["load_btn"].click` chain and `lib_refs["card_selected_name"].change` chain), add a `.then()` that refreshes the Codes tab model dropdown with the latest VQ-VAE model choices. Import `_get_vqvae_model_choices` from codes_tab (or create a refresh helper).

   Specifically, after the existing library load chain, add:
   ```python
   # If the library has a refresh function for Codes tab model dropdown:
   .then(
       fn=codes_refresh_fn,  # refreshes codes dropdown choices
       inputs=None,
       outputs=[codes_refs["model_dropdown"]],
   )
   ```

   If this is complex, a simpler approach: the Codes tab model dropdown can have a `focus` or manual refresh. Since the model dropdown is already populated on tab load, the simplest cross-tab wiring is: when a model is loaded from Library and it's a VQ-VAE model, also set it as selected in the Codes tab dropdown. Create a helper `_sync_codes_model()` that checks `app_state.loaded_vq_model` and returns `gr.update(value=model_name)`.

4. **Update the module docstring** to mention the Codes tab in the cross-tab wiring description.
  </action>
  <verify>
    <automated>cd H:/dev/Distill-vqvae && python -c "from distill.ui.app import create_app; print('App with Codes tab importable')"</automated>
  </verify>
  <done>
    - Codes tab appears between Generate and Library tabs in the UI
    - build_codes_tab imported and called in create_app
    - Library model load chain refreshes or syncs the Codes tab model dropdown
    - App docstring updated to describe Codes tab cross-tab wiring
  </done>
</task>

</tasks>

<verification>
1. `python -c "from distill.ui.tabs.codes_tab import build_codes_tab"` -- Codes tab importable
2. `python -c "from distill.ui.app import create_app"` -- App with all 5 tabs importable
3. Verify Codes tab is registered: `python -c "from distill.ui.app import create_app; app = create_app(); print('App created with Codes tab')"` (may need valid config)
</verification>

<success_criteria>
- Codes tab appears in the Gradio UI with Data, Train, Generate, Codes, Library tabs
- User can select a VQ-VAE model from dropdown (only v2 models shown)
- User can upload audio and click Encode to see the code grid with colored cells and level labels
- Clicking a cell plays preview audio via the autoplay preview player
- Clicking a column header plays the full time-slice
- Clicking Play on a row plays that level's contribution
- Decode button produces reconstruction audio for side-by-side A/B comparison
- Level labels are editable via collapsible accordion
- Library model load syncs to Codes tab dropdown
</success_criteria>

<output>
After completion, create `.planning/phases/16-encode-decode-code-visualization/16-02-SUMMARY.md`
</output>
