---
phase: 15-istft-reconstruction
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/distill/audio/spectrogram.py
  - tests/test_istft_reconstruction.py
autonomous: true
requirements: [RECON-01, RECON-02]

must_haves:
  truths:
    - "Phase is reconstructed from denormalized IF via cumulative sum starting at zero"
    - "Waveform is produced by combining denormalized magnitude with reconstructed phase via ISTFT"
    - "Round-trip encode-to-waveform via ISTFT produces audio that resembles the original (mel-domain fidelity)"
    - "Output waveforms contain no NaN/Inf values and have reasonable amplitude"
  artifacts:
    - path: "src/distill/audio/spectrogram.py"
      provides: "complex_mel_to_waveform method on ComplexSpectrogram"
      contains: "complex_mel_to_waveform"
    - path: "tests/test_istft_reconstruction.py"
      provides: "ISTFT reconstruction tests (round-trip + sanity)"
      min_lines: 50
  key_links:
    - from: "src/distill/audio/spectrogram.py"
      to: "torch.istft"
      via: "complex_mel_to_waveform calls torch.istft with reconstructed complex STFT"
      pattern: "torch\\.istft"
    - from: "src/distill/audio/spectrogram.py"
      to: "ComplexSpectrogram.denormalize"
      via: "complex_mel_to_waveform denormalizes before reconstruction"
      pattern: "denormalize|mag_std|if_std"
---

<objective>
Implement ISTFT-based waveform reconstruction on the ComplexSpectrogram class and verify it with tests.

Purpose: This is the core of Phase 15 -- converting 2-channel magnitude + IF spectrograms back to audio waveforms via exact phase reconstruction and ISTFT, replacing the lossy Griffin-Lim approach.

Output: `complex_mel_to_waveform` method on ComplexSpectrogram + comprehensive test suite
</objective>

<execution_context>
@C:/Users/Taylor/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Taylor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-istft-reconstruction/15-CONTEXT.md
@.planning/phases/12-2-channel-data-pipeline/12-01-SUMMARY.md

Key existing code:
@src/distill/audio/spectrogram.py — ComplexSpectrogram class with waveform_to_complex_mel, normalize, denormalize
@src/distill/training/config.py — ComplexSpectrogramConfig with n_fft, hop_length, n_mels
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests for ISTFT reconstruction</name>
  <files>tests/test_istft_reconstruction.py</files>
  <action>
Create a comprehensive test suite for the ISTFT reconstruction path. Tests should import ComplexSpectrogram and ComplexSpectrogramConfig and test the `complex_mel_to_waveform` method (which does not exist yet -- tests must fail).

Test cases:

1. **test_reconstruction_output_shape** -- Generate a 1-second sine wave (440 Hz, 48kHz), convert to 2-channel spectrogram via `waveform_to_complex_mel`, then call `complex_mel_to_waveform`. Assert output shape is `[B, 1, samples]` where samples is approximately the input length (within hop_length tolerance).

2. **test_reconstruction_no_nan_inf** -- Same pipeline. Assert `torch.isnan(output).sum() == 0` and `torch.isinf(output).sum() == 0`.

3. **test_reconstruction_reasonable_amplitude** -- Assert output peak amplitude is > 0.001 (not silent) and < 10.0 (not exploded).

4. **test_round_trip_sine_wave** -- Encode a 440 Hz sine wave, reconstruct via ISTFT. Compute MSE between original and reconstructed (trimmed to shorter length). Assert MSE < 0.5 (mel-domain round-trip is lossy due to mel binning, so threshold should be relaxed). This is a sanity check, not a high-fidelity test.

5. **test_round_trip_with_normalization** -- Same as above but apply normalize/denormalize round-trip before reconstruction. Compute dataset statistics on the spectrogram, normalize it, then pass normalized spectrogram + stats to `complex_mel_to_waveform`. Assert waveform is produced with no NaN and reasonable amplitude.

6. **test_reconstruction_white_noise** -- Generate white noise, round-trip through spectrogram and ISTFT. Assert output is non-silent and has no NaN. (White noise is a harder test than sine waves for spectral reconstruction.)

7. **test_batch_reconstruction** -- Batch of 2 different signals (sine + noise). Assert output batch shape is `[2, 1, samples]`.

Use ComplexSpectrogramConfig with default parameters. All tests use sample_rate=48000. Create test signals with `torch.sin` (for sine) and `torch.randn` (for noise).

The method signature to test against:
```python
complex_mel_to_waveform(
    self,
    spectrogram: torch.Tensor,  # [B, 2, n_mels, time] -- normalized or raw
    stats: dict[str, float] | None = None,  # if provided, denormalize first
    sample_rate: int = 48_000,
) -> torch.Tensor:  # [B, 1, samples]
```

When `stats` is provided, the method denormalizes before reconstruction. When `stats=None`, spectrogram is assumed to already be in raw (denormalized) form.
  </action>
  <verify>Run `python -m pytest tests/test_istft_reconstruction.py -v` -- all tests MUST FAIL (method does not exist yet). Confirm errors are `AttributeError: 'ComplexSpectrogram' object has no attribute 'complex_mel_to_waveform'`.</verify>
  <done>Test file exists with 7 test cases, all failing with AttributeError because complex_mel_to_waveform is not implemented yet.</done>
</task>

<task type="auto">
  <name>Task 2: Implement complex_mel_to_waveform on ComplexSpectrogram</name>
  <files>src/distill/audio/spectrogram.py</files>
  <action>
Add the `complex_mel_to_waveform` method to the ComplexSpectrogram class. This method reconstructs audio waveforms from 2-channel magnitude + IF spectrograms via ISTFT.

**Method signature:**
```python
def complex_mel_to_waveform(
    self,
    spectrogram: "torch.Tensor",
    stats: dict[str, float] | None = None,
    sample_rate: int = 48_000,
) -> "torch.Tensor":
```

**Implementation steps (inside the method):**

1. **Denormalize** (if stats provided): Call `self.denormalize(spectrogram, stats)` to reverse normalization. If stats is None, use spectrogram as-is.

2. **Split channels**: Extract magnitude (channel 0) and IF (channel 1) from the denormalized spectrogram. Magnitude is in log1p domain, IF is in normalized [-1, 1] domain.

3. **Undo log1p on magnitude**: Apply `torch.expm1` then clamp to >= 0 to get linear mel power. Then take `sqrt` to get mel amplitude (since original mel was power=2.0).

4. **Undo IF normalization**: Multiply IF by pi to get IF in radians ([-pi, pi] range). This reverses the `/ pi` normalization applied during encoding.

5. **Reconstruct phase via cumulative sum**: Starting from zero at time step 0 (per user decision), compute `phase_mel = torch.cumsum(if_radians, dim=-1)`. Leave phase unwrapped (per user decision -- no wrapping to [-pi, pi]).

6. **Invert mel scale to linear frequency**: Use `torchaudio.transforms.InverseMelScale` to convert both mel amplitude and mel phase back to linear frequency bins. Run InverseMelScale on CPU (project pattern -- `torch.linalg.lstsq` has MPS issues). Initialize InverseMelScale with `n_stft=n_fft//2+1, n_mels=config.n_mels, sample_rate=sample_rate`.

   For phase: InverseMelScale is designed for magnitude, not phase. Instead, use the pseudo-inverse of the mel filterbank matrix to project phase back to linear scale. Compute `pinverse_fb = torch.linalg.pinv(self.mel_scale.fb.T)` (shape [n_stft, n_mels]) and apply it: `phase_linear = torch.matmul(pinverse_fb.T, phase_mel)` — or more simply, use the same InverseMelScale transform applied to phase (it performs least-squares inversion which is mathematically equivalent to pseudo-inverse projection). The key insight: InverseMelScale minimizes least-squares error, which is a reasonable approach for phase inversion too.

   Actually, the cleanest approach: create a dedicated `self._inverse_mel` (InverseMelScale) in `__init__` and apply it to both magnitude and phase on CPU. Store it as an instance attribute.

7. **Combine magnitude + phase into complex STFT**: `stft_complex = magnitude_linear * torch.exp(1j * phase_linear)` where magnitude_linear is `[B, n_stft, time]` and phase_linear is `[B, n_stft, time]`.

8. **Apply ISTFT**: Call `torch.istft(stft_complex, n_fft=config.n_fft, hop_length=config.hop_length, window=hann_window, return_complex=False)`. Use the same hann_window that's already stored as `self._stft_window`. Result is `[B, samples]`.

9. **Return**: Unsqueeze to `[B, 1, samples]` to match the project convention.

**Also in __init__**, add the InverseMelScale transform:
```python
from torchaudio.transforms import InverseMelScale
self._inverse_mel = InverseMelScale(
    n_stft=config.n_fft // 2 + 1,
    n_mels=config.n_mels,
    sample_rate=48_000,
)
```

**Also update the `to()` method** to NOT move `_inverse_mel` (it must stay on CPU, project pattern).

**Important details:**
- InverseMelScale and the phase pinverse computation must run on CPU (move tensors to CPU before, move result back to original device after)
- The `_stft_window` must be on the same device as the input for `torch.istft`
- Handle batch dimension throughout (all operations should work on [B, ...] tensors)
  </action>
  <verify>Run `python -m pytest tests/test_istft_reconstruction.py -v` -- all 7 tests MUST PASS.</verify>
  <done>complex_mel_to_waveform method exists on ComplexSpectrogram, reconstructs waveforms from 2-channel spectrograms via IF cumsum + ISTFT, all 7 tests pass.</done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_istft_reconstruction.py -v` -- all 7 tests pass
2. `python -c "from distill.audio.spectrogram import ComplexSpectrogram; print('import OK')"` -- no import errors
3. Round-trip reconstruction produces audible, non-silent audio with no NaN/Inf
</verification>

<success_criteria>
- ComplexSpectrogram has a complex_mel_to_waveform method that converts [B, 2, n_mels, time] spectrograms to [B, 1, samples] waveforms
- Phase reconstruction uses cumulative sum starting from zero
- ISTFT produces the final waveform (no Griffin-Lim anywhere in this path)
- All 7 tests pass including round-trip quality checks
</success_criteria>

<output>
After completion, create `.planning/phases/15-istft-reconstruction/15-01-SUMMARY.md`
</output>
