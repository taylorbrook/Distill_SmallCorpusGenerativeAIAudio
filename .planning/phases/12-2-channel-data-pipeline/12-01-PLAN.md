---
phase: 12-2-channel-data-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/distill/audio/spectrogram.py
  - src/distill/training/config.py
autonomous: true
requirements:
  - DATA-01
  - DATA-02
  - DATA-03
  - DATA-04

must_haves:
  truths:
    - "Loading a waveform through ComplexSpectrogram produces a 2-channel tensor where channel 0 is magnitude and channel 1 is instantaneous frequency, both in mel domain"
    - "Magnitude and IF channels are independently normalized to zero mean and unit variance using per-dataset statistics"
    - "IF values in low-amplitude magnitude bins are masked to zero"
    - "IF masking threshold and STFT parameters are configurable in TrainingConfig"
  artifacts:
    - path: "src/distill/audio/spectrogram.py"
      provides: "ComplexSpectrogram class with waveform_to_complex_mel, normalize, denormalize, and mask_if methods"
      contains: "class ComplexSpectrogram"
    - path: "src/distill/training/config.py"
      provides: "ComplexSpectrogramConfig fields for IF masking threshold and STFT parameters"
      contains: "if_masking_threshold"
  key_links:
    - from: "src/distill/audio/spectrogram.py"
      to: "torchaudio MelSpectrogram"
      via: "mel_transform for magnitude, torch.stft for phase/IF computation"
      pattern: "torch\\.stft|MelSpectrogram"
    - from: "src/distill/audio/spectrogram.py"
      to: "src/distill/training/config.py"
      via: "ComplexSpectrogramConfig consumed by ComplexSpectrogram"
      pattern: "ComplexSpectrogramConfig"
---

<objective>
Build the core 2-channel spectrogram computation engine that converts mono waveforms into magnitude + instantaneous frequency (IF) spectrograms in mel domain, with per-dataset normalization and IF masking.

Purpose: This is the computational foundation for v2.0's complex spectrogram representation. All downstream phases (VAE architecture, loss functions, ISTFT reconstruction) depend on this 2-channel representation being correct.

Output: `ComplexSpectrogram` class in `spectrogram.py` and configuration fields in `config.py`.
</objective>

<execution_context>
@C:/Users/Taylor/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Taylor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/distill/audio/spectrogram.py
@src/distill/training/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ComplexSpectrogram class for 2-channel mel magnitude + IF computation</name>
  <files>src/distill/audio/spectrogram.py</files>
  <action>
Add a `ComplexSpectrogram` class to the existing `spectrogram.py` module (keep the existing `AudioSpectrogram` class untouched -- it is still used by v1.0 code paths). The new class computes 2-channel spectrograms from waveforms.

**Constructor:**
- Accept a `SpectrogramConfig` (reuse existing dataclass) plus `if_masking_threshold: float = 1e-5` (power threshold below which IF is masked to zero).
- Create a `torchaudio.transforms.MelSpectrogram` for magnitude (same params as existing `AudioSpectrogram`).
- Create a `torchaudio.transforms.MelScale` for projecting linear-frequency IF into mel domain.
- Use lazy imports for torch/torchaudio inside `__init__` (project pattern).
- Store the `if_masking_threshold` as an instance attribute.

**`waveform_to_complex_mel(self, waveform: torch.Tensor) -> torch.Tensor` method:**
- Input: `[B, 1, samples]` mono waveform tensor.
- Step 1: Compute mel magnitude spectrogram using the MelSpectrogram transform. Apply `log1p` normalization (same as existing `AudioSpectrogram`). Shape: `[B, n_mels, time]`.
- Step 2: Compute STFT to get complex spectrogram. Use `torch.stft(waveform, n_fft, hop_length, return_complex=True)` to get `[B, n_fft//2+1, time]` complex tensor. Compute angle: `phase = torch.angle(stft_complex)`.
- Step 3: Compute instantaneous frequency as phase difference along time axis: `if_linear = torch.diff(phase, dim=-1)` (prepend zero for first frame). Unwrap phase differences to `[-pi, pi]` range using `torch.remainder(diff + pi, 2*pi) - pi`. Normalize IF to `[-1, 1]` by dividing by pi.
- Step 4: Project IF from linear frequency bins to mel scale using `MelScale` transform: `if_mel = mel_scale(if_linear_abs) * sign`. Actually, use a simpler approach: compute IF in linear domain, then apply `MelScale` which computes a weighted sum across linear bins for each mel bin. Apply MelScale to the IF values directly since MelScale is a linear projection (weighted average of IF across linear freq bins contributing to each mel bin). This preserves the IF interpretation.
- Step 5: Apply IF masking -- compute mel power spectrogram (before log1p), create mask where power < `if_masking_threshold`, set IF to zero where mask is True.
- Step 6: Stack magnitude (channel 0) and IF (channel 1) into `[B, 2, n_mels, time]` tensor.
- Return the 2-channel tensor.

**`compute_dataset_statistics(self, spectrograms: list[torch.Tensor]) -> dict` method:**
- Input: list of 2-channel spectrogram tensors `[2, n_mels, time]` (unbatched).
- Compute per-channel mean and std across the entire dataset (not per-file).
- Return `{"mag_mean": float, "mag_std": float, "if_mean": float, "if_std": float}`.
- Handle edge case: if std is near zero (< 1e-8), set to 1.0 to avoid division by zero.

**`normalize(self, spectrogram: torch.Tensor, stats: dict) -> torch.Tensor` method:**
- Input: `[B, 2, n_mels, time]` or `[2, n_mels, time]` tensor + stats dict.
- Normalize each channel independently: `(x - mean) / std`.
- Return normalized tensor.

**`denormalize(self, spectrogram: torch.Tensor, stats: dict) -> torch.Tensor` method:**
- Input: normalized tensor + stats dict.
- Reverse: `x * std + mean`.
- Return denormalized tensor.

**`to(self, device)` method:**
- Move mel_transform and mel_scale to device (match existing pattern).

**Important design notes:**
- The `MelScale` transform can be applied to IF because it performs a linear weighted sum across frequency bins. The instantaneous frequency at each mel bin becomes the energy-weighted average IF of the contributing linear bins, which is musically meaningful.
- IF masking uses the pre-log1p mel power spectrogram as the reference for the threshold comparison. This ensures masking is based on actual energy, not log-compressed values.
- Keep the existing `AudioSpectrogram` class completely unchanged for backward compatibility.
  </action>
  <verify>
Run in Python:
```python
from distill.audio.spectrogram import ComplexSpectrogram, SpectrogramConfig
import torch
config = SpectrogramConfig()
cs = ComplexSpectrogram(config)
waveform = torch.randn(2, 1, 48000)  # 2 samples, mono, 1 second
result = cs.waveform_to_complex_mel(waveform)
assert result.shape[0] == 2  # batch
assert result.shape[1] == 2  # channels (mag + IF)
assert result.shape[2] == config.n_mels  # 128
print(f"Output shape: {result.shape}")
print(f"Mag range: [{result[:, 0].min():.4f}, {result[:, 0].max():.4f}]")
print(f"IF range: [{result[:, 1].min():.4f}, {result[:, 1].max():.4f}]")
```
Verify: output shape is `[2, 2, 128, T]`, magnitude channel is non-negative (log1p of positive values), IF channel is in `[-1, 1]` range.
  </verify>
  <done>
`ComplexSpectrogram.waveform_to_complex_mel()` produces a `[B, 2, n_mels, time]` tensor with magnitude (channel 0, non-negative) and IF (channel 1, [-1,1] range) computed in mel domain, with IF masked to zero in low-amplitude bins.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add complex spectrogram configuration fields to TrainingConfig</name>
  <files>src/distill/training/config.py</files>
  <action>
Add configuration fields for the 2-channel complex spectrogram pipeline to `TrainingConfig`. Follow the existing dataclass pattern.

**Add a new `ComplexSpectrogramConfig` dataclass** (before `TrainingConfig`):

```python
@dataclass
class ComplexSpectrogramConfig:
    """Configuration for 2-channel magnitude + IF spectrogram computation.

    Attributes
    ----------
    enabled:
        If True, use 2-channel complex spectrograms instead of 1-channel
        magnitude-only mel spectrograms. Default True for v2.0.
    if_masking_threshold:
        Power threshold below which IF values are masked to zero.
        Phase information in low-energy bins is meaningless noise.
        Higher values mask more aggressively. Default 1e-5.
    n_fft:
        FFT window size. Default 2048 (v1.0 default).
    hop_length:
        Hop length between STFT frames. Default 512 (v1.0 default).
    n_mels:
        Number of mel frequency bins. Default 128 (v1.0 default).
    """
    enabled: bool = True
    if_masking_threshold: float = 1e-5
    n_fft: int = 2048
    hop_length: int = 512
    n_mels: int = 128
```

**Add field to `TrainingConfig`:**
- Add `complex_spectrogram: ComplexSpectrogramConfig = field(default_factory=ComplexSpectrogramConfig)` field.
- Change `latent_dim` default from 64 to 128 (per v2.0 decision: "Default latent_dim 64 -> 128").

**Update `get_adaptive_config`:**
- Change the hardcoded `latent_dim=64` to `latent_dim=128` in the return statement.

**Do NOT change** any other existing fields or preset values -- those are v1.0 established behavior.
  </action>
  <verify>
Run in Python:
```python
from distill.training.config import TrainingConfig, ComplexSpectrogramConfig, get_adaptive_config
config = TrainingConfig()
assert config.latent_dim == 128
assert config.complex_spectrogram.enabled is True
assert config.complex_spectrogram.if_masking_threshold == 1e-5
assert config.complex_spectrogram.n_fft == 2048
adaptive = get_adaptive_config(10)
assert adaptive.latent_dim == 128
assert adaptive.complex_spectrogram.enabled is True
print("All config assertions passed")
```
  </verify>
  <done>
`TrainingConfig` includes `ComplexSpectrogramConfig` with configurable IF masking threshold and STFT parameters. Default `latent_dim` is 128. `get_adaptive_config` produces configs with complex spectrogram settings.
  </done>
</task>

</tasks>

<verification>
1. `ComplexSpectrogram` class exists in `spectrogram.py` and is importable
2. `waveform_to_complex_mel` produces `[B, 2, n_mels, time]` tensors from `[B, 1, samples]` waveforms
3. Channel 0 (magnitude) values are non-negative (log1p of mel power)
4. Channel 1 (IF) values are in `[-1, 1]` range (normalized by pi)
5. IF is masked to zero where mel magnitude power is below threshold
6. `compute_dataset_statistics` returns per-channel mean/std across a list of spectrograms
7. `normalize`/`denormalize` round-trip preserves values (within float precision)
8. `ComplexSpectrogramConfig` in `config.py` exposes IF masking threshold and STFT params
9. `TrainingConfig.latent_dim` defaults to 128
10. Existing `AudioSpectrogram` class is unchanged (no regressions)
</verification>

<success_criteria>
- A waveform tensor can be converted to a 2-channel magnitude + IF spectrogram via `ComplexSpectrogram`
- Both channels are computed in mel domain (not linear frequency)
- IF masking correctly zeroes out IF in low-energy bins
- Per-dataset normalization statistics can be computed and applied
- Configuration is cleanly integrated into `TrainingConfig`
</success_criteria>

<output>
After completion, create `.planning/phases/12-2-channel-data-pipeline/12-01-SUMMARY.md`
</output>
