---
phase: 09-cli-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/small_dataset_audio/cli/__init__.py
  - src/small_dataset_audio/cli/ui.py
  - src/small_dataset_audio/app.py
  - src/small_dataset_audio/__main__.py
autonomous: true

must_haves:
  truths:
    - "Running bare `sda` with no arguments launches the Gradio GUI (backward compatible)"
    - "Running `sda ui` launches the Gradio GUI with optional --device and --config flags"
    - "Running `sda --help` shows subcommands: generate, train, model, ui"
    - "Typer is installed and CLI framework is functional"
  artifacts:
    - path: "src/small_dataset_audio/cli/__init__.py"
      provides: "Typer app, bootstrap() function, subcommand registration, default GUI callback"
      exports: ["app", "main", "bootstrap"]
    - path: "src/small_dataset_audio/cli/ui.py"
      provides: "sda ui command that launches Gradio"
      contains: "def ui"
    - path: "pyproject.toml"
      provides: "typer dependency and updated entry point"
      contains: "typer"
  key_links:
    - from: "pyproject.toml"
      to: "src/small_dataset_audio/cli/__init__.py"
      via: "entry point sda = small_dataset_audio.cli:main"
      pattern: 'sda = "small_dataset_audio.cli:main"'
    - from: "src/small_dataset_audio/cli/__init__.py"
      to: "src/small_dataset_audio/ui"
      via: "bootstrap + launch_ui in default callback and ui command"
      pattern: "launch_ui"
---

<objective>
Create the CLI skeleton with Typer, bootstrap function, `sda ui` command, and update entry points so bare `sda` launches the GUI (backward compatible) while enabling subcommands.

Purpose: Foundation layer that all other CLI commands depend on. Must maintain backward compatibility where bare `sda` launches the GUI.
Output: Working `sda` command with `ui` subcommand, `--help` showing all subcommand slots, and shared bootstrap() function.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-cli-interface/09-CONTEXT.md
@.planning/phases/09-cli-interface/09-RESEARCH.md
@src/small_dataset_audio/app.py
@src/small_dataset_audio/__main__.py
@src/small_dataset_audio/__init__.py
@src/small_dataset_audio/ui/__init__.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Typer and create CLI package with bootstrap and app scaffold</name>
  <files>
    pyproject.toml
    src/small_dataset_audio/cli/__init__.py
    src/small_dataset_audio/cli/ui.py
  </files>
  <action>
1. Add typer dependency to pyproject.toml: `"typer>=0.23,<1.0"` in [project] dependencies list.

2. Update entry point in pyproject.toml [project.scripts]: change `sda = "small_dataset_audio.app:main"` to `sda = "small_dataset_audio.cli:main"`.

3. Create `src/small_dataset_audio/cli/__init__.py` with:
   - Import typer, create main Typer app with `no_args_is_help=False`.
   - App name="sda", help="Small Dataset Audio - Generative audio from small personal datasets".
   - `bootstrap(config_path, device)` function that loads config via `config.settings.load_config`/`get_config_path` and selects device via `hardware.device.select_device`. Returns `(config_dict, torch_device, config_path)`. Uses lazy imports for torch/hardware modules inside the function body.
   - `@app.callback(invoke_without_command=True)` that checks `ctx.invoked_subcommand is None` and if so, runs the full legacy startup flow (first_run_setup if needed, startup validation, device selection, launch_ui). Import `app.first_run_setup`, `validation.startup.run_startup_validation`, `ui.launch_ui` lazily inside the callback. Accept `--device` (default "auto"), `--verbose` (flag), `--config` (optional Path) as callback-level options so they apply to all subcommands.
   - Register sub-typers for generate, train, model (import and add_typer). These imports will fail until Plans 02/03 create those modules, so use try/except ImportError to skip gracefully during development. The ui command is registered directly.
   - `main = app` at module level (the entry point callable).

4. Create `src/small_dataset_audio/cli/ui.py` with:
   - A Typer sub-app (or use `@app.command()` registered in __init__.py -- choose the simpler approach of defining a `ui` command function in __init__.py directly, and do NOT create a separate ui.py file if the command is short enough).
   - Actually, keep ui.py for consistency with the module-per-command pattern.
   - `app = typer.Typer()` with a single `@app.command()` (or `@app.callback(invoke_without_command=True)`) named implicitly.
   - The ui command function: accepts no extra args beyond the global --device/--config from the parent callback. Calls bootstrap() then launch_ui(config=config, device=device). First-run setup and startup validation should run before launch.
   - Lazy imports inside command body.

5. Run `uv add "typer>=0.23,<1.0"` to install. Then `uv run sda --help` to verify.

IMPORTANT: The callback-level --device, --verbose, --config options must be stored on the Typer Context object (via `ctx.ensure_object(dict)` or similar) so subcommands can access them. Alternatively, use module-level variables or pass through bootstrap(). The research recommends keeping it simple -- the callback stores values in a module-level dict or passes them down.

IMPORTANT: bare `sda` (no subcommand) MUST launch the GUI, matching current behavior. Test this explicitly.

IMPORTANT: Do NOT import torch or any heavy modules at module level in cli/ files. All heavy imports must be inside function bodies for fast `sda --help` response.
  </action>
  <verify>
Run `uv run sda --help` -- should show subcommands and global options, complete in under 1 second.
Run `uv run python -c "from small_dataset_audio.cli import app, bootstrap; print('OK')"` -- should succeed.
  </verify>
  <done>
`sda --help` displays help with generate/train/model/ui subcommands listed. `sda ui --help` shows ui command help. Typer is installed. bootstrap() function exists and is importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update app.py and __main__.py for new CLI entry point</name>
  <files>
    src/small_dataset_audio/app.py
    src/small_dataset_audio/__main__.py
  </files>
  <action>
1. Update `__main__.py` to import from the new CLI entry point:
   ```python
   from small_dataset_audio.cli import main
   if __name__ == "__main__":
       main()
   ```

2. In `app.py`, keep the existing `first_run_setup()` and `parse_args()` functions (they are still used by the CLI callback for the legacy flow). The `main()` function in app.py can remain but is no longer the entry point -- it is now a fallback. Optionally, refactor `main()` to call the CLI's main, or simply leave it as-is for backward compatibility if someone imports `app.main()` directly.

   The key change: `parse_args()` is no longer needed by the new CLI (Typer handles argument parsing). But `first_run_setup()` IS still needed by the CLI callback. Keep both functions in app.py. The `main()` function in app.py can be updated to simply call `cli.main()` as a thin redirect, or left as-is.

   Recommended: Leave app.py mostly unchanged. The only thing that changes is `__main__.py` pointing to `cli:main` instead of `app:main`. The `app.py:main()` still works if someone calls it directly but is no longer the console_script entry point.

3. Verify `uv run python -m small_dataset_audio --help` works (uses __main__.py which now calls cli.main).

IMPORTANT: Do not break any existing imports of `small_dataset_audio.app`. Other modules (like tests) may import `first_run_setup` or other functions from app.py.
  </action>
  <verify>
Run `uv run python -m small_dataset_audio --help` -- should show CLI help (same as `sda --help`).
Run `uv run python -c "from small_dataset_audio.app import first_run_setup; print('OK')"` -- should still work.
  </verify>
  <done>
`python -m small_dataset_audio` and `sda` both route to the Typer CLI. `app.py` functions remain importable. Bare `sda` with no args launches GUI flow (first-run check, validation, device selection, Gradio launch).
  </done>
</task>

</tasks>

<verification>
1. `uv run sda --help` completes in <1s and shows: generate, train, model, ui subcommands
2. `uv run sda ui --help` shows ui command help text
3. `uv run python -m small_dataset_audio --help` matches `sda --help` output
4. `uv run python -c "from small_dataset_audio.cli import app, bootstrap, main; print('OK')"` succeeds
5. `uv run python -c "from small_dataset_audio.app import first_run_setup; print('OK')"` succeeds
</verification>

<success_criteria>
- Typer installed as dependency
- CLI package exists at src/small_dataset_audio/cli/
- `sda --help` shows all subcommand groups
- `sda` with no args triggers GUI launch flow (backward compatible)
- `sda ui` triggers GUI launch flow
- bootstrap() function loadable and returns (config, device, config_path)
- Entry point updated in pyproject.toml
- __main__.py updated to use CLI entry point
- No heavy imports at module level in cli/ modules
</success_criteria>

<output>
After completion, create `.planning/phases/09-cli-interface/09-01-SUMMARY.md`
</output>
