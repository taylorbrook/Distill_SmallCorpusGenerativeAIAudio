---
phase: 07-presets-generation-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/small_dataset_audio/presets/__init__.py
  - src/small_dataset_audio/presets/manager.py
  - src/small_dataset_audio/config/defaults.py
autonomous: true

must_haves:
  truths:
    - "User can save current slider configuration as a named preset scoped to a model"
    - "User can recall a saved preset to restore slider positions and seed"
    - "User can browse, rename, and delete saved presets"
    - "User can organize presets into folders (create, rename, delete folders)"
  artifacts:
    - path: "src/small_dataset_audio/presets/manager.py"
      provides: "PresetEntry dataclass and PresetManager class with full CRUD + folder management"
      exports: ["PresetEntry", "PresetManager"]
    - path: "src/small_dataset_audio/presets/__init__.py"
      provides: "Public API exports for preset module"
      exports: ["PresetEntry", "PresetManager"]
    - path: "src/small_dataset_audio/config/defaults.py"
      provides: "Updated DEFAULT_CONFIG with presets and history paths"
      contains: "presets"
  key_links:
    - from: "src/small_dataset_audio/presets/manager.py"
      to: "src/small_dataset_audio/controls/mapping.py"
      via: "load_preset returns (SliderState, seed) tuple"
      pattern: "SliderState"
    - from: "src/small_dataset_audio/presets/manager.py"
      to: "presets.json index file"
      via: "atomic write pattern from library/catalog.py"
      pattern: "os\\.replace"
---

<objective>
Preset management system with model-scoped CRUD and virtual folder organization.

Purpose: Enable users to save, recall, browse, rename, and delete slider configuration presets organized into folders. Presets are model-specific (PCA axes differ per model) and store slider positions + optional seed. No duration stored (locked decision). No audio preview on save (locked decision).

Output: `presets/manager.py` with PresetEntry dataclass and PresetManager class, `presets/__init__.py` with public API, updated config defaults with preset and history paths.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-presets-generation-history/07-RESEARCH.md
@src/small_dataset_audio/library/catalog.py
@src/small_dataset_audio/controls/mapping.py
@src/small_dataset_audio/config/defaults.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PresetEntry dataclass and PresetManager with CRUD and folder management</name>
  <files>src/small_dataset_audio/presets/manager.py</files>
  <action>
Create `src/small_dataset_audio/presets/manager.py` following the exact patterns from `library/catalog.py` (JSON index, atomic writes, graceful corrupt handling).

**PresetEntry dataclass:**
- Fields: preset_id (str, UUID), name (str), folder (str, empty="" for root), slider_positions (list[int]), n_components (int), seed (int | None where None = random each time), created (str, ISO 8601), modified (str, ISO 8601), description (str = "")
- Use `from __future__ import annotations` and `dataclasses.dataclass`
- Match the code example from 07-RESEARCH.md Pattern 2

**PresetManager class:**
Constructor takes `presets_dir: Path` and `model_id: str`. Creates `self._model_dir = presets_dir / model_id` and `self._index_path = _model_dir / "presets.json"`. Calls `_load_index()` on init.

JSON index structure:
```json
{
  "version": 1,
  "model_id": "...",
  "folders": [{"name": "Pads", "created": "..."}],
  "presets": {"preset-uuid": {...}}
}
```

**Preset CRUD methods:**
- `save_preset(name, slider_positions, n_components, seed=None, folder="", description="") -> PresetEntry` -- creates UUID, timestamps, adds to index, atomic save
- `load_preset(preset_id) -> tuple[SliderState, int | None]` -- returns (SliderState, seed). Import SliderState from controls.mapping. Raises KeyError if not found.
- `get_preset(preset_id) -> PresetEntry | None` -- lookup by ID
- `list_presets(folder: str | None = None) -> list[PresetEntry]` -- all presets, optionally filtered by folder, sorted by modified descending
- `rename_preset(preset_id, new_name) -> PresetEntry` -- updates name + modified timestamp. Raises KeyError if not found.
- `update_preset(preset_id, slider_positions, n_components, seed=None) -> PresetEntry` -- updates slider data + modified timestamp (for overwriting a preset with new values). Raises KeyError if not found.
- `delete_preset(preset_id) -> bool` -- returns True if deleted, False if not found
- `count() -> int` -- number of presets

**Folder management methods (virtual folders -- string field, not filesystem):**
- `create_folder(name: str) -> None` -- strip whitespace, reject empty, reject duplicates (case-insensitive). Raises ValueError.
- `rename_folder(old_name: str, new_name: str) -> int` -- bulk update all presets with folder==old_name to new_name. Update folders list. Return count of presets updated. Raises ValueError if old not found or new exists.
- `delete_folder(name: str, move_presets_to: str = "") -> int` -- move presets to target folder (default root ""), remove folder from list, return count moved. Raises ValueError if not found.
- `list_folders() -> list[str]` -- sorted folder names

**Internal methods:**
- `_load_index()` -- read JSON, deserialize PresetEntry dicts. Handle missing/corrupt gracefully (log warning, start fresh). Use `json.loads(path.read_text(encoding="utf-8"))`.
- `_save_index()` -- serialize to JSON dict, write atomically. Copy the `_write_index_atomic` pattern from library/catalog.py (temp file + os.replace + .bak backup). Do NOT import from catalog -- copy the pattern locally as a module-level function `_write_index_atomic(index_path, data)`.

**Important:**
- Seed serialization: `None` maps to JSON `null`, integer maps to integer. Handle explicitly in deserialization (do not let `null` become `0`).
- Use `dataclasses.asdict` for PresetEntry serialization.
- Module-level logger via `logging.getLogger(__name__)`.
- Lazy imports not needed (all stdlib).
  </action>
  <verify>
Run `uv run python -c "from small_dataset_audio.presets.manager import PresetEntry, PresetManager; import tempfile, pathlib; d = tempfile.mkdtemp(); pm = PresetManager(pathlib.Path(d), 'test-model'); p = pm.save_preset('Test', [0,1,-2], 3, seed=42); assert p.name == 'Test'; assert p.seed == 42; loaded = pm.load_preset(p.preset_id); print('SliderState:', loaded[0]); print('Seed:', loaded[1]); pm.create_folder('Pads'); pm.rename_preset(p.preset_id, 'Renamed'); assert pm.get_preset(p.preset_id).name == 'Renamed'; assert pm.delete_preset(p.preset_id); assert pm.count() == 0; print('All preset operations passed')"` from the project root.
  </verify>
  <done>
PresetManager supports full CRUD (save/load/get/list/rename/update/delete) and folder management (create/rename/delete/list). Presets are model-scoped, store slider_positions + seed (no duration), use UUID IDs, and persist via atomic JSON writes. Seed None round-trips correctly through JSON serialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create presets __init__.py and update config defaults</name>
  <files>src/small_dataset_audio/presets/__init__.py, src/small_dataset_audio/config/defaults.py</files>
  <action>
**1. Create `src/small_dataset_audio/presets/__init__.py`:**
Export PresetEntry and PresetManager from the presets package:
```python
"""Preset management for slider configurations.

Public API:
- PresetEntry: dataclass for a single preset
- PresetManager: CRUD and folder management for model-scoped presets
"""

from small_dataset_audio.presets.manager import PresetEntry, PresetManager

__all__ = ["PresetEntry", "PresetManager"]
```

**2. Update `src/small_dataset_audio/config/defaults.py`:**
Add "presets" and "history" keys to the "paths" section of DEFAULT_CONFIG:
```python
"paths": {
    "datasets": "data/datasets",
    "models": "data/models",
    "generated": "data/generated",
    "presets": "data/presets",    # NEW
    "history": "data/history",    # NEW
},
```
Do NOT change any other section. Only add the two new path keys.
  </action>
  <verify>
Run `uv run python -c "from small_dataset_audio.presets import PresetEntry, PresetManager; print('Presets package OK'); from small_dataset_audio.config.defaults import DEFAULT_CONFIG; assert 'presets' in DEFAULT_CONFIG['paths']; assert 'history' in DEFAULT_CONFIG['paths']; print('Config paths OK')"` from the project root.
  </verify>
  <done>
Presets package has clean public API (PresetEntry, PresetManager). Config defaults include paths for both presets and history data directories.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from small_dataset_audio.presets import PresetEntry, PresetManager"` -- imports succeed
2. PresetManager round-trip test: save -> load -> get -> list -> rename -> delete
3. Folder management: create -> list -> rename -> delete with preset migration
4. Seed None serialization: save preset with seed=None, reload, confirm seed is None (not 0)
5. Config defaults contain presets and history paths
</verification>

<success_criteria>
- PresetManager provides save_preset, load_preset, get_preset, list_presets, rename_preset, update_preset, delete_preset, count
- PresetManager provides create_folder, rename_folder, delete_folder, list_folders
- Presets are model-scoped (one JSON index per model_id directory)
- PresetEntry stores slider_positions + seed, NOT duration (locked decision)
- No audio preview generated on save (locked decision)
- JSON index uses atomic write pattern (temp file + os.replace + .bak backup)
- Config defaults updated with presets and history paths
</success_criteria>

<output>
After completion, create `.planning/phases/07-presets-generation-history/07-01-SUMMARY.md`
</output>
