---
phase: 07-presets-generation-history
plan: 03
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - src/small_dataset_audio/history/comparison.py
  - src/small_dataset_audio/history/__init__.py
autonomous: true

must_haves:
  truths:
    - "User can A/B compare two generations from history"
    - "User can toggle between A and B audio at the same playback position"
    - "User can save the winning generation's parameters as a preset via keep_winner"
  artifacts:
    - path: "src/small_dataset_audio/history/comparison.py"
      provides: "ABComparison dataclass with toggle, get_audio_paths, and keep_winner"
      exports: ["ABComparison"]
    - path: "src/small_dataset_audio/history/__init__.py"
      provides: "Complete history public API with ABComparison added"
      exports: ["HistoryEntry", "GenerationHistory", "ABComparison"]
  key_links:
    - from: "src/small_dataset_audio/history/comparison.py"
      to: "src/small_dataset_audio/history/store.py"
      via: "get_audio_paths and keep_winner look up history entries"
      pattern: "GenerationHistory"
    - from: "src/small_dataset_audio/history/comparison.py"
      to: "src/small_dataset_audio/presets/manager.py"
      via: "keep_winner delegates to PresetManager.save_preset"
      pattern: "PresetManager"
---

<objective>
A/B comparison runtime state and final public API wiring.

Purpose: Enable users to compare two generations side-by-side with a toggle A/B button, and save the winner's parameters as a preset. A/B comparison is a lightweight runtime state object (not persisted) that references two history entries and provides audio path resolution and a "keep this one" action.

Output: `history/comparison.py` with ABComparison dataclass, updated `history/__init__.py` with complete public API.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-presets-generation-history/07-RESEARCH.md
@.planning/phases/07-presets-generation-history/07-01-SUMMARY.md
@.planning/phases/07-presets-generation-history/07-02-SUMMARY.md
@src/small_dataset_audio/history/store.py
@src/small_dataset_audio/presets/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ABComparison dataclass with toggle, audio paths, and keep_winner</name>
  <files>src/small_dataset_audio/history/comparison.py</files>
  <action>
Create `src/small_dataset_audio/history/comparison.py` implementing A/B comparison as runtime state (NOT persisted -- locked decision: A/B state is ephemeral UI state).

**ABComparison dataclass:**
```python
@dataclass
class ABComparison:
    """Runtime state for A/B comparison between two generations.

    This is ephemeral UI state -- not persisted to disk. It holds
    references to two history entries (or one entry + the current
    live generation) and provides audio path resolution and a
    "keep this one" action.

    Locked decisions honored:
    - Toggle A/B button: single play control, toggle switches between A and B
    - Audio-only comparison: no visual parameter diff
    - Supports: current/latest vs history entry, OR any two history entries
    - "Keep this one": saves winner's parameters as a preset
    """

    entry_a_id: str | None  # History entry ID. None = current/live generation
    entry_b_id: str | None  # History entry ID. None = current/live generation
    active_side: str = "a"  # "a" or "b" -- which side is currently playing
```

**Methods:**

`toggle() -> str`:
- Switch active_side between "a" and "b". Return the new active side.
- Simple: `self.active_side = "b" if self.active_side == "a" else "a"`

`get_active_entry_id() -> str | None`:
- Return the entry_id for the currently active side. Returns None if active side is a live generation (entry_id is None).

`get_audio_paths(history: GenerationHistory) -> tuple[Path | None, Path | None]`:
- Return (path_a, path_b) as absolute Paths to the WAV files for each side.
- If entry_a_id is None, path_a is None (means use the current live audio buffer -- UI handles this).
- If entry_b_id is None, path_b is None.
- For non-None IDs, look up the history entry via `history.get(entry_id)` and resolve `history.history_dir / entry.audio_file` to get the absolute path.
- Raise ValueError if an entry_id is not None but not found in history.

`get_entry(side: str, history: GenerationHistory) -> HistoryEntry | None`:
- Return the HistoryEntry for the given side ("a" or "b").
- Returns None if that side's entry_id is None (live generation).
- Raises ValueError if side is not "a" or "b".

`keep_winner(winner: str, preset_name: str, history: GenerationHistory, preset_manager: PresetManager) -> PresetEntry`:
- Save the winning side's parameters as a preset.
- `winner` must be "a" or "b". Raises ValueError otherwise.
- Get the entry_id for the winning side. Raises ValueError if winner's entry_id is None (cannot save live generation -- it must be in history first).
- Look up the HistoryEntry via `history.get(entry_id)`. Raises KeyError if not found.
- Raise ValueError if entry has no slider_positions (slider_positions is None).
- Delegate to `preset_manager.save_preset(name=preset_name, slider_positions=entry.slider_positions, n_components=entry.n_components, seed=entry.seed)`.
- Return the created PresetEntry.

**Class methods (convenience constructors):**

`@classmethod from_current_and_history(cls, history_entry_id: str) -> ABComparison`:
- Default mode (locked decision): compare current/latest generation (A) against one history entry (B).
- Returns `ABComparison(entry_a_id=None, entry_b_id=history_entry_id)`

`@classmethod from_two_entries(cls, entry_a_id: str, entry_b_id: str) -> ABComparison`:
- Compare any two history entries (locked decision: also supported).
- Returns `ABComparison(entry_a_id=entry_a_id, entry_b_id=entry_b_id)`

**Imports:**
- Use `from __future__ import annotations`
- Use `TYPE_CHECKING` guard for GenerationHistory, PresetManager, PresetEntry, HistoryEntry (avoid circular imports)
- Module-level logger via `logging.getLogger(__name__)`
  </action>
  <verify>
Run `uv run python -c "
from small_dataset_audio.history.comparison import ABComparison

# Test construction
ab = ABComparison.from_current_and_history('some-entry-id')
assert ab.entry_a_id is None
assert ab.entry_b_id == 'some-entry-id'
assert ab.active_side == 'a'

# Test toggle
new_side = ab.toggle()
assert new_side == 'b'
assert ab.active_side == 'b'
new_side = ab.toggle()
assert new_side == 'a'

# Test from_two_entries
ab2 = ABComparison.from_two_entries('id-1', 'id-2')
assert ab2.entry_a_id == 'id-1'
assert ab2.entry_b_id == 'id-2'

print('All ABComparison tests passed')
"` from the project root.
  </verify>
  <done>
ABComparison provides toggle(), get_audio_paths(), get_entry(), keep_winner(), and convenience constructors from_current_and_history() and from_two_entries(). A/B state is ephemeral (not persisted). keep_winner delegates to PresetManager.save_preset. Audio-only comparison (no visual parameter diff) per locked decision.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update history __init__.py with ABComparison and run integration smoke test</name>
  <files>src/small_dataset_audio/history/__init__.py</files>
  <action>
**1. Update `src/small_dataset_audio/history/__init__.py`:**
Add ABComparison to the public API exports:

```python
"""Generation history tracking and A/B comparison.

Public API:
- HistoryEntry: dataclass for a single generation history entry
- GenerationHistory: CRUD for generation history with WAV + thumbnail storage
- ABComparison: runtime state for A/B comparison between two generations
"""

from small_dataset_audio.history.comparison import ABComparison
from small_dataset_audio.history.store import GenerationHistory, HistoryEntry

__all__ = ["ABComparison", "GenerationHistory", "HistoryEntry"]
```

**2. Run integration smoke test:**
Verify the full integration chain works:
- Import all three packages (presets, history, config)
- Create a PresetManager, save a preset, load it back
- Create a GenerationHistory (empty)
- Create an ABComparison via both constructors
- Verify toggle works
- Verify config defaults have both paths

This is a verification-only step -- if imports and basic operations work, the data layer is ready for Phase 8 UI integration.
  </action>
  <verify>
Run `uv run python -c "
# Full integration smoke test
from small_dataset_audio.presets import PresetEntry, PresetManager
from small_dataset_audio.history import HistoryEntry, GenerationHistory, ABComparison
from small_dataset_audio.config.defaults import DEFAULT_CONFIG
import tempfile, pathlib

# Verify config paths
assert 'presets' in DEFAULT_CONFIG['paths']
assert 'history' in DEFAULT_CONFIG['paths']
print('Config OK')

# Verify presets
d = tempfile.mkdtemp()
pm = PresetManager(pathlib.Path(d), 'model-123')
p = pm.save_preset('Test Preset', [0, 1, -3, 5], 4, seed=None, folder='')
loaded_state, loaded_seed = pm.load_preset(p.preset_id)
assert loaded_state.positions == [0, 1, -3, 5]
assert loaded_seed is None  # seed=None round-trips correctly
print('Presets OK')

# Verify history
hd = tempfile.mkdtemp()
gh = GenerationHistory(pathlib.Path(hd))
assert gh.count() == 0
print('History OK')

# Verify A/B comparison
ab = ABComparison.from_current_and_history('entry-1')
assert ab.toggle() == 'b'
ab2 = ABComparison.from_two_entries('entry-a', 'entry-b')
assert ab2.entry_a_id == 'entry-a'
print('A/B Comparison OK')

print('--- ALL PHASE 7 INTEGRATION TESTS PASSED ---')
"` from the project root.
  </verify>
  <done>
Complete history public API exports ABComparison alongside HistoryEntry and GenerationHistory. Full integration smoke test passes: presets, history, A/B comparison, and config defaults all work together. Phase 7 data layer is ready for Phase 8 UI consumption.
  </done>
</task>

</tasks>

<verification>
1. `from small_dataset_audio.history import ABComparison, HistoryEntry, GenerationHistory` -- all three import
2. `from small_dataset_audio.presets import PresetEntry, PresetManager` -- both import
3. ABComparison.toggle() switches between "a" and "b"
4. ABComparison.from_current_and_history() sets entry_a_id=None (live generation)
5. ABComparison.from_two_entries() sets both entry IDs
6. Full integration: preset save -> A/B compare -> keep_winner chain works conceptually (full chain requires actual GenerationResult which needs a trained model)
</verification>

<success_criteria>
- ABComparison is a runtime-only dataclass (not persisted, locked decision)
- Toggle A/B switches active_side between "a" and "b" (locked decision: single play control)
- Audio-only comparison: no visual parameter diff (locked decision)
- Default mode: current/latest generation (A=None) vs history entry (B=entry_id) (locked decision)
- Also supports any two history entries (locked decision)
- keep_winner saves winner's parameters as a preset via PresetManager (locked decision)
- Complete public API: presets.{PresetEntry, PresetManager}, history.{HistoryEntry, GenerationHistory, ABComparison}
</success_criteria>

<output>
After completion, create `.planning/phases/07-presets-generation-history/07-03-SUMMARY.md`
</output>
