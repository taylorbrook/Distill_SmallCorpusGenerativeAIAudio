---
phase: 07-presets-generation-history
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/small_dataset_audio/history/__init__.py
  - src/small_dataset_audio/history/store.py
autonomous: true

must_haves:
  truths:
    - "User can view a history of past generations with waveform thumbnails and parameter snapshots"
    - "History entries store both the audio file (WAV) and full parameter snapshot"
    - "History is reverse-chronological with unlimited retention"
    - "User can delete individual history entries with file cleanup"
  artifacts:
    - path: "src/small_dataset_audio/history/store.py"
      provides: "HistoryEntry dataclass and GenerationHistory class with add/list/get/delete"
      exports: ["HistoryEntry", "GenerationHistory"]
    - path: "src/small_dataset_audio/history/__init__.py"
      provides: "Public API exports for history module (partial -- comparison added in Plan 03)"
      exports: ["HistoryEntry", "GenerationHistory"]
  key_links:
    - from: "src/small_dataset_audio/history/store.py"
      to: "src/small_dataset_audio/inference/export.py"
      via: "export_wav called to save WAV to history/audio/"
      pattern: "export_wav"
    - from: "src/small_dataset_audio/history/store.py"
      to: "src/small_dataset_audio/audio/thumbnails.py"
      via: "generate_waveform_thumbnail called for history entry thumbnails"
      pattern: "generate_waveform_thumbnail"
    - from: "src/small_dataset_audio/history/store.py"
      to: "history.json index file"
      via: "atomic write pattern"
      pattern: "os\\.replace"
---

<objective>
Generation history storage with WAV files, waveform thumbnails, and parameter snapshots.

Purpose: Enable users to browse past generations in reverse-chronological order with waveform thumbnails, full parameter details, and instant audio replay. Each history entry stores the audio file (WAV) and complete parameter snapshot. Unlimited retention with manual delete.

Output: `history/store.py` with HistoryEntry dataclass and GenerationHistory class, `history/__init__.py` with public API.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-presets-generation-history/07-RESEARCH.md
@src/small_dataset_audio/library/catalog.py
@src/small_dataset_audio/inference/generation.py
@src/small_dataset_audio/inference/export.py
@src/small_dataset_audio/audio/thumbnails.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HistoryEntry dataclass and GenerationHistory with add/list/get/delete</name>
  <files>src/small_dataset_audio/history/store.py</files>
  <action>
Create `src/small_dataset_audio/history/store.py` following the JSON index + atomic write pattern from `library/catalog.py`.

**HistoryEntry dataclass:**
Fields (match 07-RESEARCH.md Pattern 3):
- entry_id: str (UUID)
- timestamp: str (ISO 8601)
- model_id: str
- model_name: str
- slider_positions: list[int] | None (None if generated without sliders)
- n_components: int
- seed: int
- duration_s: float
- sample_rate: int
- stereo_mode: str
- preset_name: str ("custom" if no preset was used)
- audio_file: str (relative to history_dir, e.g. "audio/{entry_id}.wav")
- thumbnail_file: str (relative to history_dir, e.g. "thumbnails/{entry_id}.png")
- quality_score: dict (default_factory=dict)
- latent_vector: list[float] | None = None (stored as list for JSON serialization)

Use `from __future__ import annotations`, `dataclasses.dataclass`, `dataclasses.field`.

**GenerationHistory class:**
Constructor takes `history_dir: Path`. Sets `self._index_path = history_dir / "history.json"`. Calls `_load_index()`.

JSON index structure:
```json
{
  "version": 1,
  "entries": {
    "entry-uuid": { ... HistoryEntry fields ... }
  }
}
```

**Methods:**

`add_to_history(result, model_id, model_name, slider_positions, n_components, preset_name) -> HistoryEntry`:
- Takes a GenerationResult (from inference.generation) plus contextual info.
- Use lazy imports inside the method body for GenerationResult type, export_wav, and generate_waveform_thumbnail (project pattern).
- Order of operations is CRITICAL for consistency (Research Pitfall #7):
  1. Generate entry_id via uuid.uuid4()
  2. Create `history_dir/audio/` dir (mkdir parents=True, exist_ok=True)
  3. Save WAV to `audio/{entry_id}.wav` using `export_wav(audio=result.audio, path=audio_path, sample_rate=result.sample_rate, bit_depth=result.config.bit_depth)`
  4. Create `history_dir/thumbnails/` dir
  5. Generate thumbnail to `thumbnails/{entry_id}.png` using `generate_waveform_thumbnail(waveform=result.audio, output_path=thumb_path, width=400, height=60)` -- smaller than dataset thumbnails
  6. Create HistoryEntry with all fields populated from result + params
  7. Convert latent_vector: `result.config.latent_vector.tolist()` if not None, else None
  8. Add to `self._entries` dict
  9. Save index atomically
- If WAV write fails, do NOT add to index (consistency).

`list_entries(model_id: str | None = None, limit: int | None = None) -> list[HistoryEntry]`:
- Return entries sorted by timestamp descending (reverse-chronological, locked decision).
- Optionally filter by model_id.
- Optionally limit to N most recent.

`get(entry_id: str) -> HistoryEntry | None`:
- Lookup by entry_id.

`delete_entry(entry_id: str) -> bool`:
- Delete audio file, thumbnail file, then remove from index (files first, then index -- same principle as WAV-before-index).
- Return True if deleted, False if not found.
- Use try/except on file unlink (file may already be missing).

`get_total_size() -> int`:
- Sum file sizes of all audio files and thumbnail files referenced in index.
- Skip missing files gracefully.
- Return total bytes.

`count() -> int`:
- Return number of entries.

`repair_history() -> tuple[int, int]`:
- Similar to ModelLibrary.repair_index.
- Remove entries whose audio file is missing from disk (mark as stale, remove from index).
- Return (removed_count, orphan_count) where orphan_count is audio files in audio/ dir not referenced by any entry (report but do not delete -- user may want them).

**Internal methods:**
- `_load_index()` -- read JSON, deserialize to dict[str, HistoryEntry]. Handle missing/corrupt gracefully.
- `_save_index()` -- serialize and write atomically. Copy `_write_index_atomic` pattern locally (same as presets/manager.py -- do NOT import from catalog.py, copy the pattern).

**Important:**
- Module-level logger via `logging.getLogger(__name__)`.
- `from __future__ import annotations` for modern type hints.
- Lazy imports for `export_wav`, `generate_waveform_thumbnail` inside method body (heavy dependencies).
- `dataclasses.asdict` for HistoryEntry serialization to JSON.
- Slider positions None handling: JSON null round-trips correctly.
  </action>
  <verify>
Run `uv run python -c "
from small_dataset_audio.history.store import HistoryEntry, GenerationHistory
import tempfile, pathlib
d = tempfile.mkdtemp()
gh = GenerationHistory(pathlib.Path(d))
assert gh.count() == 0
print('Empty history OK')

# Test with a mock-like approach (just verify the class structure)
import uuid
from datetime import datetime, timezone
entry = HistoryEntry(
    entry_id=str(uuid.uuid4()),
    timestamp=datetime.now(timezone.utc).isoformat(),
    model_id='test-model',
    model_name='Test Model',
    slider_positions=[0, 1, -2],
    n_components=3,
    seed=42,
    duration_s=2.5,
    sample_rate=48000,
    stereo_mode='mono',
    preset_name='custom',
    audio_file='audio/test.wav',
    thumbnail_file='thumbnails/test.png',
)
print('HistoryEntry dataclass OK:', entry.entry_id[:8])
print('All history store tests passed')
"` from the project root.
  </verify>
  <done>
GenerationHistory supports add_to_history (WAV + thumbnail + index), list_entries (reverse-chronological, filterable by model), get, delete_entry (with file cleanup), get_total_size, count, and repair_history. History entries store both audio file and full parameter snapshot. Unlimited retention with manual delete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create history __init__.py with public API exports</name>
  <files>src/small_dataset_audio/history/__init__.py</files>
  <action>
Create `src/small_dataset_audio/history/__init__.py` with public API exports:

```python
"""Generation history tracking and A/B comparison.

Public API:
- HistoryEntry: dataclass for a single generation history entry
- GenerationHistory: CRUD for generation history with WAV + thumbnail storage
"""

from small_dataset_audio.history.store import GenerationHistory, HistoryEntry

__all__ = ["GenerationHistory", "HistoryEntry"]
```

Note: ABComparison will be added to this __init__.py in Plan 03. For now, export only the store classes.
  </action>
  <verify>
Run `uv run python -c "from small_dataset_audio.history import HistoryEntry, GenerationHistory; print('History package imports OK')"` from the project root.
  </verify>
  <done>
History package has clean public API exports. HistoryEntry and GenerationHistory importable from `small_dataset_audio.history`.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from small_dataset_audio.history import HistoryEntry, GenerationHistory"` -- imports succeed
2. HistoryEntry dataclass has all required fields (entry_id, timestamp, model_id, model_name, slider_positions, n_components, seed, duration_s, sample_rate, stereo_mode, preset_name, audio_file, thumbnail_file, quality_score, latent_vector)
3. GenerationHistory round-trip: add_to_history (with real GenerationResult), list_entries, get, delete_entry
4. Delete cleans up WAV and thumbnail files
5. Atomic JSON writes for history index
</verification>

<success_criteria>
- GenerationHistory.add_to_history saves WAV then thumbnail then updates index (correct order for consistency)
- list_entries returns reverse-chronological order (most recent first, locked decision)
- Unlimited retention (no auto-pruning, locked decision)
- delete_entry cleans up audio file + thumbnail + index entry
- History entries store full parameter snapshot (slider_positions, seed, model_id, duration, sample_rate, stereo_mode, preset_name, quality_score, latent_vector)
- get_total_size computes cumulative disk usage
- repair_history detects stale entries with missing audio files
</success_criteria>

<output>
After completion, create `.planning/phases/07-presets-generation-history/07-02-SUMMARY.md`
</output>
