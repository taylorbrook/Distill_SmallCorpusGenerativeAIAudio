---
phase: 10-multi-format-export-spatial-audio
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/small_dataset_audio/inference/export.py
  - src/small_dataset_audio/audio/metadata.py
autonomous: true

must_haves:
  truths:
    - "User can export audio as MP3 at 320 kbps CBR"
    - "User can export audio as FLAC with level 8 compression"
    - "User can export audio as OGG Vorbis at quality 6 (~192 kbps)"
    - "Exported MP3/FLAC/OGG files contain embedded metadata tags (artist, album, model name, seed)"
    - "WAV export continues to work identically to Phase 4 behavior"
    - "Sidecar JSON is written for all formats (complements embedded tags)"
  artifacts:
    - path: "src/small_dataset_audio/inference/export.py"
      provides: "ExportFormat enum, export_audio dispatcher, export_mp3, export_flac, export_ogg"
      contains: "class ExportFormat"
    - path: "src/small_dataset_audio/audio/metadata.py"
      provides: "Format-aware metadata embedding via mutagen"
      contains: "embed_metadata"
    - path: "pyproject.toml"
      provides: "lameenc and mutagen dependencies"
      contains: "lameenc"
  key_links:
    - from: "src/small_dataset_audio/inference/export.py"
      to: "src/small_dataset_audio/audio/metadata.py"
      via: "export_audio calls embed_metadata after encoding"
      pattern: "embed_metadata"
---

<objective>
Multi-format audio export engine with MP3, FLAC, OGG encoding and embedded metadata tagging.

Purpose: Enable users to export generated audio in any common format with embedded provenance metadata, not just WAV. This is the foundation for format selection across UI, CLI, and history re-export.

Output: Extended `export.py` with `ExportFormat` enum and `export_audio()` dispatcher; new `metadata.py` with mutagen-based tag embedding; `lameenc` and `mutagen` added as dependencies.
</objective>

<execution_context>
@/Users/taylorbrook/.claude/get-shit-done/workflows/execute-plan.md
@/Users/taylorbrook/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-multi-format-export-spatial-audio/10-CONTEXT.md
@.planning/phases/10-multi-format-export-spatial-audio/10-RESEARCH.md
@src/small_dataset_audio/inference/export.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and extend export.py with ExportFormat enum and MP3/FLAC/OGG encoders</name>
  <files>
    pyproject.toml
    src/small_dataset_audio/inference/export.py
  </files>
  <action>
1. Add `lameenc>=1.7` and `mutagen>=1.47` to the project dependencies in `pyproject.toml` (in the `[project] dependencies` list). Run `uv lock` to update the lockfile.

2. Extend `src/small_dataset_audio/inference/export.py`:
   - Add `ExportFormat` enum with values: WAV, MP3, FLAC, OGG (string values "wav", "mp3", "flac", "ogg").
   - Add `FORMAT_EXTENSIONS` dict mapping ExportFormat -> file extension string (".wav", ".mp3", ".flac", ".ogg").
   - Add `export_mp3()` function:
     - Accepts `audio: np.ndarray`, `path: Path`, `sample_rate: int = 48_000`, `bitrate: int = 320`
     - Converts float32 audio to int16 PCM bytes (clip to [-1, 1], multiply by 32767)
     - Handles mono [samples] and stereo [2, samples] (stereo: transpose to [samples, 2] then flatten for interleaving)
     - Uses lameenc.Encoder with `set_bit_rate(bitrate)`, `set_in_sample_rate(sample_rate)`, `set_channels(channels)`, `set_quality(2)` (highest quality)
     - Writes `encoder.encode(pcm_bytes) + encoder.flush()` to path
     - Returns path
   - Add `export_flac()` function:
     - Accepts `audio: np.ndarray`, `path: Path`, `sample_rate: int = 48_000`, `compression_level: int = 8`
     - Uses soundfile.write with `format='FLAC'`, `subtype='PCM_24'`
     - Maps compression_level (0-8) to soundfile's float (compression_level / 8.0)
     - Handles [2, samples] -> [samples, 2] transpose (existing soundfile pattern)
     - Returns path
   - Add `export_ogg()` function:
     - Accepts `audio: np.ndarray`, `path: Path`, `sample_rate: int = 48_000`, `quality: float = 0.6`
     - Uses soundfile.write with `format='OGG'`, `subtype='VORBIS'`
     - Maps quality to soundfile's compression_level as `1.0 - quality` (inverted: 0.0=max quality, 1.0=min quality). Quality 0.6 -> compression 0.4 -> ~192 kbps VBR.
     - Handles [2, samples] -> [samples, 2] transpose
     - Returns path
   - Add `export_audio()` unified dispatcher:
     - Accepts `audio, path, sample_rate, format: ExportFormat, bit_depth="24-bit", metadata: dict | None = None`
     - Dispatches to export_wav/export_mp3/export_flac/export_ogg based on format
     - After encoding, calls `embed_metadata(path, format, metadata)` from `audio.metadata` if metadata is not None
     - Writes sidecar JSON (calls existing `write_sidecar_json`) for ALL formats
     - Returns path
   - Keep existing `export_wav()` unchanged (backward compatibility)
   - Use lazy imports for lameenc, soundfile, numpy (project pattern)
  </action>
  <verify>
    Run: `uv run python -c "from small_dataset_audio.inference.export import ExportFormat, export_audio, export_mp3, export_flac, export_ogg; print('OK')"` succeeds.
    Run: `uv run python -c "import lameenc; import mutagen; print('deps OK')"` succeeds.
  </verify>
  <done>
    ExportFormat enum exists. export_mp3 encodes at 320 kbps CBR via lameenc. export_flac writes FLAC at level 8 via soundfile. export_ogg writes OGG Vorbis at quality 6 via soundfile. export_audio dispatches to correct encoder by format. Existing export_wav unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create metadata.py for format-aware tag embedding via mutagen</name>
  <files>
    src/small_dataset_audio/audio/metadata.py
    src/small_dataset_audio/audio/__init__.py
    src/small_dataset_audio/inference/__init__.py
  </files>
  <action>
1. Create `src/small_dataset_audio/audio/metadata.py`:
   - Module docstring: "Format-aware audio metadata embedding via mutagen."
   - Add `DEFAULT_METADATA` dict with `artist: "SDA Generator"` and `album: ""` defaults (per user decision: Artist = "SDA Generator", Album = model name).
   - Add `embed_metadata(path: Path, format: ExportFormat, metadata: dict) -> None`:
     - Lazy imports for mutagen (project pattern)
     - For MP3: Use `mutagen.id3.ID3()` with `TPE1` (artist), `TALB` (album), `TIT2` (title), and custom `TXXX` frames for `SDA_SEED`, `SDA_MODEL`, `SDA_PRESET` from metadata dict. Save to file path.
     - For FLAC: Use `mutagen.flac.FLAC(str(path))` with Vorbis Comment keys: `artist`, `album`, `title`, `sda_seed`, `sda_model`, `sda_preset`. Call `audio.save()`.
     - For OGG: Use `mutagen.oggvorbis.OggVorbis(str(path))` with same Vorbis Comment keys as FLAC (values must be list of strings). Call `audio.save()`.
     - For WAV: No-op (WAV uses sidecar JSON only, per existing Phase 4 pattern).
     - All fields from metadata dict that are present are embedded. Missing fields use defaults from DEFAULT_METADATA.
   - Add `build_export_metadata(model_name: str, seed: int | None, preset_name: str | None = None, overrides: dict | None = None) -> dict`:
     - Builds the standard metadata dict with: artist (default "SDA Generator"), album (model_name), title (auto-generated or from overrides), seed, model_name, preset_name.
     - Applies overrides dict on top (user can override any tag per locked decision).
     - Returns the metadata dict ready for embed_metadata.

2. Update `src/small_dataset_audio/audio/__init__.py`:
   - Add import of `embed_metadata` and `build_export_metadata` from `audio.metadata`.
   - Add both to `__all__`.

3. Update `src/small_dataset_audio/inference/__init__.py`:
   - Add import of `ExportFormat`, `export_audio` from `inference.export`.
   - Add both to `__all__`.
  </action>
  <verify>
    Run: `uv run python -c "from small_dataset_audio.audio.metadata import embed_metadata, build_export_metadata; print('OK')"` succeeds.
    Run: `uv run python -c "from small_dataset_audio.inference import ExportFormat, export_audio; print('OK')"` succeeds.
  </verify>
  <done>
    metadata.py embeds tags into MP3 (ID3), FLAC (Vorbis Comments), and OGG (Vorbis Comments). build_export_metadata produces standard metadata dict with SDA Generator branding and user-overridable fields. Public API re-exports updated for both audio and inference packages.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from small_dataset_audio.inference.export import ExportFormat, export_audio, export_mp3, export_flac, export_ogg; print('All exports available')"` -- passes
2. `uv run python -c "from small_dataset_audio.audio.metadata import embed_metadata, build_export_metadata; print('Metadata module available')"` -- passes
3. `uv run python -c "import lameenc; import mutagen; print('Dependencies installed')"` -- passes
4. `uv run python -c "from small_dataset_audio.inference.export import ExportFormat; assert ExportFormat.MP3.value == 'mp3'; assert ExportFormat.FLAC.value == 'flac'; assert ExportFormat.OGG.value == 'ogg'; print('Enum values correct')"` -- passes
</verification>

<success_criteria>
- ExportFormat enum with WAV, MP3, FLAC, OGG values
- export_mp3 produces MP3 at 320 kbps CBR via lameenc
- export_flac produces FLAC at compression level 8 via soundfile
- export_ogg produces OGG Vorbis at quality 6 (~192 kbps) via soundfile
- export_audio dispatches to correct encoder and applies metadata
- embed_metadata writes ID3 tags for MP3, Vorbis Comments for FLAC/OGG
- build_export_metadata returns dict with "SDA Generator" artist, model name as album
- Sidecar JSON written for all formats (existing pattern preserved)
- Existing export_wav function unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/10-multi-format-export-spatial-audio/10-01-SUMMARY.md`
</output>
